function fn1(a) {
    var b = a * 2;
    function fn2(c) {
        console.log(a, b, c);
    }
    fn2(b * 3);
}
fn1(1); // 2, 4, 12


//引擎执行 console.log(..)，并查找 a 、 b 和 c 三个变量的引用。
//它首先从最内部的作用域，也就是 fn2(..) 函数的作用域气泡开始查找。引擎无法在这里找到 a，
//因此会去上一级到所嵌套的 fn1(..) 的作用域中继续查找。在这里找到了 a，
//因此引擎使用了这个引用。对 b  来讲也是一样的。而对 c 来说，引擎在 fn2(..) 中就找到
//了它。如果 a 、b、 c 都存在于 fn2(..) 和 fn1(..) 的内部，
// console.log(..) 就可以直接使用 fn2(..) 中的变量，而无需到外面的 fn1(..) 中查找。


//作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的
//标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，
//作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见
//第一个匹配的标识符为止。